# -*- coding: utf-8 -*-
"""bovespaML.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1joIjBTONpjoSWXz2D3u84GZveQMAc94r
"""

# !pip install  numpy==1.23.5
# !pip install pmdarima

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from statsmodels.tsa.arima.model import ARIMA
from statsmodels.tsa.stattools import adfuller
from pandas.plotting import register_matplotlib_converters

from pmdarima.arima import auto_arima

df = pd.read_csv('/content/drive/MyDrive/Colab Notebooks/bovespa_stocks.csv')
df.head()

df['Date'] = pd.to_datetime(df['Date'], utc=True, format='ISO8601' )
df.head()

df['Symbol'].unique()

tims3df = df[df['Symbol'] == 'TIMS3']

"""Preencher valores ausentes"""

tims3df = tims3df[['Date','Adj Close']].set_index('Date', drop=True).sort_index()
tims3df = tims3df.drop_duplicates()
all_dates = pd.Series(pd.date_range(start=tims3df.index.min(), end=tims3df.index.max(), freq='D'))#freq='D': Especifica a frequência da sequência de datas. 'D' significa "diariamente". Portanto, essa parte gera uma sequência de todas as datas entre a data mais antiga e a data mais recente encontradas no índice de tims3df, com um intervalo de um dia.
tims3df = tims3df.reindex(all_dates, method='ffill')
# tims3df = tims3df['Adj Close'].interpolate()
tims3df.head()



plt.figure(figsize=(12,8))
plt.plot(tims3df, label = 'Adj Close')
plt.legend()
plt.show()

"""##1 rodada de **testes**"""

train = tims3df[:"2019-12-31 00:00:00+00:00"]
test = tims3df["2020-01-01 00:00:00+00:00":]

fig, ax = plt.subplots()

train.plot(ax=ax)
test.plot(ax=ax)
ax.legend(['train', 'test'])
plt.show()

model = auto_arima(train, trace = True, error_action = 'ignore', suppress_warnings = True)

model.fit(train)



fig, ax = plt.subplots()

train.plot(ax=ax)
test.plot(ax=ax)
forecasts.plot(ax=ax)

plt.fill_between(test.index, confidence[:,0], confidence[:,1], alpha = 0.1, color = 'b')

ax.legend(['train', 'Test', "Pred"])

"""## Testar com Prophet"""

!pip install sktime

from pmdarima.model_selection import train_test_split
from sklearn.model_selection import GridSearchCV
from sktime.forecasting.base import ForecastingHorizon
from sktime.forecasting.fbprophet import Prophet
from xgboost import XGBRegressor

forecaster2 = Prophet(
    seasonality_mode = 'multiplicative',
    n_changepoints = len(train) //12,
    add_country_holidays = {'country_name': 'BR'},
    yearly_seasonality = True,
)

# Define o modo como as sazonalidades (anual, semanal, etc.) serão modeladas em relação à tendência.
# Valor usado: 'multiplicative'
# Explicação:
# Em modo multiplicativo, as componentes sazonais, de feriados e de tendência não se somam, mas se multiplicam. Isso é útil em séries temporais onde a amplitude da sazonalidade varia proporcionalmente ao nível da tendência (por exemplo, vendas que aumentam ao longo dos anos e cujas flutuações sazonais também se ampliam).


# Define o número de "changepoints" (pontos de mudança), que são locais ao longo da série temporal onde o modelo é autorizado a ajustar a tendência.

# Valor usado: len(train) // 12

# Explicação:
# Aqui, o número de changepoints é definido como o tamanho do conjunto de treinamento (train) dividido por 12. Isso indica que, aproximadamente, haverá 1 ponto de mudança para cada 12 observações.

# Importância:
# Mais changepoints permitem que o modelo capture mudanças mais frequentes na tendência, mas em excesso podem causar overfitting. Um valor mais baixo força o modelo a uma tendência mais suave.


# Descrição:
# Indica se o modelo deve automaticamente ajustar uma componente de sazonalidade anual.

# Valor usado: True

# Explicação:
# Ao definir como True, o Prophet incluirá uma função periódica (baseada em séries de Fourier) para capturar padrões que se repetem a cada ano, como ciclos climáticos, vendas sazonais, entre outros.

# Detalhe adicional:
# Você também poderia passar um inteiro (por exemplo, yearly_seasonality=10) para definir manualmente o número de termos de Fourier que controlam a complexidade dessa sazonalidade.

train.index = train.index.tz_localize(None) #tz_localize(None) é um método do pandas que remove a informação de fuso horário de um DatetimeIndex que está associado a um timezone (como UTC, America/Sao_Paulo, etc.).
test.index = test.index.tz_localize(None)

forecaster2.fit(train)
horizon = ForecastingHorizon(test.index, is_relative=False)
forecast = forecaster2.predict(fh = horizon)

fig, ax = plt.subplots()
train.plot(ax = ax)
test.plot(ax = ax)
forecasts.plot(ax = ax)
ax.legend(["Treino", "Teste", "Predição"])

